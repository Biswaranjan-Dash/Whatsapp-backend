
# Prompt for GitHub Copilot / AI dev assistant

Build a small, production-quality FastAPI service (MVP) implementing a **patient registration + doctor scheduling + appointment booking + check-in queue** system. Follow SOLID principles, keep routers thin, and separate repositories / services / schemas. Use **async FastAPI + async SQLAlchemy + PostgreSQL + Alembic**. Provide tests and a reproducible local dev environment (Docker Compose). Write clean, typed Python with good logging, clear errors, and OpenAPI docs.

---

## Summary / scope (MVP)
1. **Patient registration** — minimal patient info persisted to Postgres.  
2. **Doctor master list** + **Doctor daily availability** (secondary list / attendance) with an API to update availability for a specific date.  
3. **Appointment booking** — max **10 appointments per doctor per day**. Enforce atomically and idempotently.  
4. **Check-in** — patient checks in on the appointment day → added to doctor's queue; queue positions assigned in checked-in order.

Do **not** implement UI. Focus on API, database, tests and concurrency-safety.

---

## Tech stack & non-functional requirements
- Python latest stable
- FastAPI (async).  
- SQLAlchemy async ORM.  
- Alembic for migrations.  
- PostgreSQL (use Docker Compose for dev).   
- Docker Compose: services: app, postgres, redis (optional).  
- Logging: structured JSON logs, redaction helper for PHI.  
- OpenAPI (auto-generated by FastAPI).  
- Use UUID primary keys. Use timestamptz for timestamps.

Coding style: clear type hints, small functions, docstrings, dependency injection via FastAPI `Depends`. Keep DB models and Pydantic schemas separate.
dont add unnecessary comments just keep minimal comments.

---

## Architecture / folders (required)
```
project-root/
├─ app/
│  ├─ main.py
│  ├─ core/
│  │  ├─ config.py
│  │  └─ logging.py
│  ├─ api/
│  │  └─ v1/
│  │     ├─ routers/
│  │     │  ├─ patients.py
│  │     │  ├─ doctors.py
│  │     │  ├─ appointments.py
│  │     │  └─ checkins.py
│  │     └─ deps.py
│  ├─ services/
│  │  ├─ patient_service.py
│  │  ├─ doctor_service.py
│  │  ├─ appointment_service.py
│  │  └─ queue_service.py
│  ├─ repositories/
│  │  ├─ patient_repo.py
│  │  ├─ doctor_repo.py
│  │  ├─ appointment_repo.py
│  │  └─ queue_repo.py
│  ├─ db/
│  │  ├─ base.py
│  │  ├─ session.py
│  │  └─ migrations/  # alembic env
│  ├─ models/   # SQLAlchemy ORM models
│  └─ schemas/  # Pydantic request/response models
├─ tests/
│  ├─ unit/
│  └─ integration/
├─ docker-compose.yml
├─ Dockerfile
├─ alembic.ini
├─ pyproject.toml / requirements.txt
└─ README.md
```

---

## Database models (required fields)

Use UUIDs as PKs. Example column types shown for guidance — implement as SQLAlchemy models.

**Patient**
- id: UUID (PK)  
- first_name: str (required)  
- last_name: str (optional)  
- **age: int (optional)**  
- phone: str (indexed, normalized)  
- email: str (optional)  
- created_at: timestamptz (default now)

**DoctorMaster**
- id: UUID  
- name: str  
- code: str (unique)  
- specialty: str (optional)  
- created_at

**DoctorDailyAvailability**
- id: UUID  
- doctor_id: FK(DoctorMaster)  
- date: date  
- is_present: bool  
- notes: text (optional)  
- updated_by: str (optional)  
- updated_at: timestamptz  
- unique index on (doctor_id, date)

**DoctorDailyCapacity** (recommended for concurrency)
- id: UUID  
- doctor_id: FK  
- date: date  
- capacity: int (default 10)  
- remaining: int  
- unique(doctor_id, date)

**Appointment**
- id: UUID  
- patient_id: FK(Patient)  
- doctor_id: FK(DoctorMaster)  
- date: date  
- slot: int (1..10)  
- status: enum('booked', 'cancelled', 'checked_in', 'completed')  
- idempotency_key: str (optional, indexed)  
- created_at, updated_at  
- unique index on (doctor_id, date, slot)

**QueueEntry**
- id: UUID  
- appointment_id: FK(Appointment)  
- doctor_id: FK  
- date: date  
- position: int (1..N)  
- checked_in_at: timestamptz  
- status: enum('waiting', 'served', 'skipped')  
- unique index on (doctor_id, date, position)

---

## API contract (essential endpoints — return JSON)

### Patients
- `POST /api/v1/patients`  
  - Body: `{first_name, last_name?, age?, phone, email?}`  
  - Response 201: `{id, first_name, last_name, age, phone, email, created_at}`

- `GET /api/v1/patients/{patient_id}`

### Doctors
- `GET /api/v1/doctors`  
- `POST /api/v1/doctors` `{name, code, specialty?}`  
- `GET /api/v1/doctors/{doctor_id}`

### Availability
- `POST /api/v1/doctors/{doctor_id}/availability` — upsert  
  - Body: `{date: "YYYY-MM-DD", is_present: bool, notes?: str}`  
  - Response: 200/201 with availability record.

- `GET /api/v1/doctors/{doctor_id}/availability?date=YYYY-MM-DD`

### Appointments (booking)
- `POST /api/v1/appointments`  
  - Body: `{patient_id, doctor_id, date: "YYYY-MM-DD", idempotency_key?}`  
  - Responses:
    - `201 Created` → `{appointment_id, slot, status}`  
    - `409 Conflict` when capacity full or doctor absent  
    - `400 / 404` appropriate validation/found errors

- `GET /api/v1/appointments/{appointment_id}`  
- `GET /api/v1/doctors/{doctor_id}/appointments?date=YYYY-MM-DD`

### Check-in
- `POST /api/v1/checkins`  
  - Body: `{appointment_id, patient_id}`  
  - Behavior: validate appointment exists, status == 'booked', date == today; atomically insert QueueEntry (position = current_count + 1) and set appointment.status = 'checked_in'  
  - Response: `{queue_position, checked_in_at}` or `409` if already checked-in.

- `GET /api/v1/doctors/{doctor_id}/queue?date=YYYY-MM-DD` — returns ordered waiting list.

---

## Business rules & invariants (must be enforced)
1. **Max 10 appointments/doctor/date**. Enforce atomically via DB.  
2. **Idempotent booking**: if request contains `idempotency_key`, duplicate requests with same key must return the same appointment (store mapping).  
3. **Doctor must be present** on that date to accept bookings (check daily availability; fallback to default schedule only if availability row is absent and you decide to allow). If `is_present==false` → reject booking 422/409.  
4. **Check-in only allowed on appointment date**; cannot check-in earlier/later.  
5. **Queue positions assigned in checked-in order** (atomic increment).  
6. **DB constraints**: unique `(doctor_id, date, slot)` and `(doctor_id, date, position)` to protect invariants.

---

## Concurrency-safe booking algorithm (recommended)
Use a `doctor_daily_capacity` record and atomic UPDATE:

1. Ensure a `DoctorDailyCapacity` row exists for (doctor_id, date) with `capacity=10` and `remaining=10`. Create on-demand if absent.  
2. In a DB transaction, perform:
```sql
UPDATE doctor_daily_capacity
SET remaining = remaining - 1
WHERE doctor_id = :doctor_id AND date = :date AND remaining > 0
RETURNING remaining;
```
3. If no row returned → capacity full → return HTTP 409.  
4. If returned, calculate `slot = capacity - remaining` (or maintain a `next_slot` column) and insert `appointment` with that slot.  
5. Ensure unique constraint on `(doctor_id, date, slot)` and handle constraint violation gracefully (map to 409).

Alternative: `SELECT ... FOR UPDATE` on capacity row, count appointments, then insert. Both fine — prefer the atomic update approach for high concurrency.

---

## Check-in atomicity
- When checking in, wrap in a transaction:
  1. Verify appointment status == 'booked' and date == today.
  2. Insert QueueEntry with `position = (SELECT COALESCE(MAX(position),0)+1 FROM queue_entries WHERE doctor_id=... AND date=...)` using `FOR UPDATE` or rely on a `queue_position_sequence` row for atomic increment.
  3. Update appointment.status = 'checked_in'.
- Add unique constraint on `(doctor_id, date, position)` to prevent duplicates.

---

## Error handling & responses
- Use consistent JSON error model: `{ "error": "Code", "message": "User friendly", "details": {...} }`
- Map these errors:
  - `400 Bad Request` — validation
  - `404 Not Found` — missing resources
  - `409 Conflict` — capacity full, duplicate slot, idempotency conflict
  - `422 Unprocessable Entity` — business rule violation (doctor absent)
  - `500 Internal Server Error`

---

## Tests (mandatory)
- **Unit tests** for services with mocked repos.  
- **Integration tests** with Docker Postgres:
  - Normal booking flow (create patient, create doctor, ensure capacity row, book 10 appointments → 10 successes, 11th fails).
  - Concurrency test: spawn 30 concurrent booking attempts for same doctor/date; assert only 10 succeed.  
  - Check-in flow: checking in assigns positions in order; double-check-in returns `409`.  
  - Idempotency: repeated booking with same idempotency_key returns same appointment and does not consume extra slots.  
- Provide fixtures for creating test patient and doctor.

---

## Migrations & dev environment
- Provide Alembic migrations for all models.  
- `docker-compose.yml` with app (uvicorn), postgres (data volume), and optional pgadmin. Provide `.env` sample values for DB connection.  
- README: setup steps, run migrations, run tests, sample curl commands.

---

## Deliverables & acceptance criteria
- Fully functioning FastAPI app with endpoints above.  
- Alembic migrations and Docker Compose to run locally.  
- Unit & integration tests with `pytest` demonstrating concurrency safety and idempotency.  
- README with launch steps and example API calls (curl).  
- Clean code: type hints, docstrings, linting (pass ruff/black), consistent logging, error mapping.  
- OpenAPI docs available via `/docs`.

---

## Example curl flows (include in README)
1. Create patient
```bash
curl -X POST http://localhost:8000/api/v1/patients \
 -H "Content-Type: application/json" \
 -d '{"first_name": "John", "last_name": "Doe", "phone": "+919876543210", "age": 34}'
```
2. Create doctor
```bash
curl -X POST http://localhost:8000/api/v1/doctors -d '{"name":"Dr A", "code":"DR_A"}'
```
3. Set availability
```bash
curl -X POST http://localhost:8000/api/v1/doctors/<id>/availability \
 -d '{"date":"2025-11-15", "is_present": true}'
```
4. Book appointment
```bash
curl -X POST http://localhost:8000/api/v1/appointments \
 -d '{"patient_id":"<pid>", "doctor_id":"<did>", "date":"2025-11-15", "idempotency_key":"abc-123"}'
```
5. Check-in (on appointment date)
```bash
curl -X POST http://localhost:8000/api/v1/checkins -d '{"appointment_id":"<aid>", "patient_id":"<pid>"}'
```

---

## Implementation notes for Copilot
- Keep routers thin: parse & validate input, call service methods, map exceptions to HTTP responses.  
- Services contain transactional business logic; repositories contain only DB operations.  
- Use `Depends` for DB session injection.  
- Use Pydantic models for request/response; separate internal DB models.  
- Handle DB unique constraint exceptions and map to 409 with clear message.  
- Write concise tests demonstrating concurrency safety; use `asyncio.gather` to spawn concurrent requests or use `httpx.AsyncClient` against FastAPI app.  
- Provide migration files and ensure app can create missing `doctor_daily_capacity` rows lazily when first booking if desired.

---

## Extra (nice-to-have, optional)
- Postman collection or OpenAPI client export.  
- Simple healthcheck endpoint `/health` and metrics endpoint `/metrics`.  
- Hook for background workers (e.g., notifications) — stubbed only.

---

### Final instruction for Copilot:
Implement the MVP exactly as specified above. Prioritize correctness (concurrency safety, idempotency, DB constraints), tests, and clear README. Keep commits small and meaningful and include an integration test that proves only 10 bookings succeed under concurrent booking attempts. Use the folder layout and coding style described.
